# ⚡️ Effect Hook (useEffect)

## ❗️Effect Hook (기본 형태)

#### useEffect(함수)

- useEffect의 첫 번째 인자는 함수이다.
- useEffect의 첫 번째 인자는 함수 내에서 Side Effect를 실행하면 된다.
- useEffect의 첫 번째 인자는 함수는 다음과 같은 조건에서 실행된다.

#### 👉 실행 조건

- 컴포넌트 생성 후 처음 화면에 렌더링
- 컴포넌트에 새로운 props가 전달되며 렌더링
- 컴포넌트에 상태(state)가 바뀌며 렌더링

##### 이와 같이 매 번 새롭게 컴포넌트가 렌더링될 때 Effect Hook이 실행된다.

<br><br><br>

## ❗️Effect Hook (조건부 실행)

#### useEffect(함수, [종속성1, 종속성2, ...])

- useEffect의 두 번째 인자는 배열이다.
- useEffect의 두 번째 인자인 배열은 **종속성 배열**이다.
- useEffect의 두 번째 인자인 배열은 조건을 담고 있다.
  <br>
- 여기서 조건은 Boolean 형태의 표현식이 아니다.
- 여기서 조건은 **어떤 값의 변경이 일어날 때**를 의미한다.
- 따라서, 해당 배열엔 어떤 값의 목록이 들어간다.
- 이러한 배열을 특별히 종속성 배열(Dependency Array)이라고 부른다.

#### 👉 실행 조건

- 배열 내의 어떤 값이 변할 때에만, (effect가 발생하는) 함수가 실행된다.
- 예를 들어 배열 내의 종속성1 또는 종속성2의 값이 변할 때, 첫번째 인자의 함수가 실행된다.

#### 👉 단 한번만 실행되는 Effect 함수

- 만일 종속성 목록에 아무런 종속성도 없다면 어떤 일이 발생할까?
- 달리 말해, 두번째 배열을 빈 배열[]로 둘 경우에는 무슨일이 발생할까?
- 두번째 인자를 아예 안넘기는 것과 어떻게 다를까?

### 1. 아무것도 넣지 않기 (기본 형태)

### useEffect(함수)

- useEffect의 두 번째 인자가 없는 경우 (기본 형태)
- **컴포넌트가 처음 생성되거나, props가 업데이트되거나, 상태(state)가 업데이트될 때 effect 함수가 실행된다.**

### 2. 빈 배열 넣기

### useEffect(함수, [])

- useEffect의 두 번째 인자고, 빈 배열일 경우
- **컴포넌트가 처음 생성**될때만 effect 함수가 실행된다.
- 대표적으로 처음 단 한번, 외부 API를 통해 리소스를 받아오고 더이상 API 호출이 필요하지 않을 때에 사용할 수 있다.

<br><br><br>

## ❗️Hook을 쓸 때 주의할 점

- 최상위에서만 Hook을 호출한다.
- React 함수 내에서 Hook을 호출한다.
- [Hook의 규칙 – React](https://ko.reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level)

<br><br><br>

## 질문!

### useEffect는 해당 컴포넌트 내에서 side effect가 발생하면 실행된다는 것인가?

useEffect의 첫 번째 인자인 함수가 해당 컴포넌트에 side effect를 만들어 낸다는 것인가?

## 답변 정리!

컴포넌트 라이프 사이클 후크’에 대한 이해부터 함수형 컴포넌트에서의 ‘라이프 사이클 후크’인 useEffect에 대한 자세한 개념을 알 수 있었습니다.

1. useEffect는 해당 컴포넌트 내에서 side effect가 발생하면 실행된다는 것인가?는
   라이프 사이클이라는 개념과 useEffect후크 사용법에 대해 알게되면서 아닌 것으로 깨달았습니다.
   useEffect는 사용방법에 따라, 컴포넌트 생명주기와 관련해서 발생한다는 것이라는 것을 알았습니다.

2. useEffect의 첫 번째 인자인 함수가 해당 컴포넌트에 side effect를 만들어 낸다는 것인가?는
   맞다라는 것을 알았습니다.
   이유는 후크라는 것이 해당 라이프 사이클에서 잠깐! 하고 끼어드는 것 처럼 발생을 하는데
   이때 useEffect의 첫 번째 인자인 함수의 구현에 따라 side effect를 발생 시킬 수도 있기 때문이다.

<br><br><br>

## Data Fetching: 필터링 예제

### 목록 내 필터링을 구현하기 위해서는 다음과 같은 두가지 접근이 있을 수 있다.

- **컴포넌트 내에서 필터링**: 전체 목록 데이터를 불러오고, 목록을 검색어로 filter 하는 방법
- **컴포넌트 외부에서 필터링**: 컴포넌트 외부로 API 요청을 할 때에, 필터링한 결과를 받아오는 방법 (보통, 서버에 매번 검색어와 함께 요청하는 경우에 해당)
  <br><br>

### 두 방식의 차이점

컴포넌트 내부에서 처리 :
장점 : HTTP 요청의 빈도를 줄일 수 있다.
단점 : 브라우저(클라이언트)의 메모리 상에 많은 데이터를 갖게 되므로, 클라이언트의 부담이 늘어난다.

컴포넌트 외부에서 처리 :
장점 : 클라이언트가 필터링 구현을 생각하지 않아도 된다.
단점 : 빈번한 HTTP 요청이 일어나게 되며, 서버가 필터링을 처리하므로 서버가 부담을 가져간다.

[출처](https://hanamon.kr/codestates-til-%ED%95%AD%ED%95%B4%EC%9D%BC%EC%A7%80-35%EC%9D%BC%EC%B0%A8/)
